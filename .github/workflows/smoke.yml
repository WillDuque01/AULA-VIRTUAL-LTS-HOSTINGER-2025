name: Smoke

on:
  workflow_dispatch:
    inputs:
      base_url:
        description: 'URL base a monitorear (default: HOSTINGER_APP_URL)'
        required: false
      locale:
        description: 'Locale principal para construir rutas (ej. es)'
        required: false
        default: es
      extra_paths:
        description: "Rutas adicionales (una por lÃ­nea, empiezan con /)"
        required: false
  schedule:
    - cron: '30 12 * * *'
  workflow_run:
    workflows: ['Deploy']
    types:
      - completed

jobs:
  smoke:
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      BASE_URL: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.base_url != '' && github.event.inputs.base_url || secrets.HOSTINGER_APP_URL }}
      LOCALE: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.locale != '' && github.event.inputs.locale || 'es' }}
      EXTRA_PATHS: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.extra_paths != '' && github.event.inputs.extra_paths || '' }}
    steps:
      - name: Resolver URL base
        id: setup
        run: |
          base="${BASE_URL%/}"
          if [ -z "$base" ]; then
              echo "âŒ BASE_URL no estÃ¡ definido (input o secreto HOSTINGER_APP_URL)." >&2
              exit 1
          fi
          echo "base=$base" >> "$GITHUB_OUTPUT"
          echo "âœ… Usando base: $base"

      - name: Ejecutar smoke tests
        run: |
          set -euo pipefail
          base="${{ steps.setup.outputs.base }}"
          endpoints=$'/'$'\n'"/${LOCALE}"$'\n'"/${LOCALE}/login"$'\n'"/${LOCALE}/dashboard"

          if [ -n "${EXTRA_PATHS:-}" ]; then
            cleaned=$(printf '%s\n' "$EXTRA_PATHS" | sed '/^\s*$/d')
            if [ -n "$cleaned" ]; then
              endpoints="$endpoints"$'\n'"$cleaned"
            fi
          fi

          echo "ðŸ” Realizando smoke tests:"
          while IFS= read -r path; do
            trimmed=$(printf '%s' "$path" | xargs)
            if [ -z "$trimmed" ]; then
              continue
            fi

            full_url="$base$trimmed"
            echo "â†’ $full_url"
            curl --fail --show-error --silent --max-time 12 \
              -H "User-Agent: LTS-SMOKE/${GITHUB_RUN_ID}" \
              "$full_url" >/dev/null
          done <<< "$endpoints"

          echo "âœ… Todos los endpoints respondieron correctamente."

      - name: Notify Slack
        if: ${{ always() && secrets.SLACK_WEBHOOK_URL != '' }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          STATUS: ${{ job.status }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          CONTEXT: ${{ github.event_name }}
        run: |
          set -euo pipefail
          status_icon="âœ…"
          status_text="Smoke OK"
          if [ "$STATUS" != "success" ]; then
            status_icon="âŒ"
            status_text="Smoke fallÃ³"
          fi
          case "$CONTEXT" in
            workflow_run)
              context_label="post-deploy"
              ;;
            schedule)
              context_label="programado"
              ;;
            *)
              context_label="manual"
              ;;
          esac

          payload=$(jq -n \
            --arg text "$status_icon $status_text ($context_label) â€” $RUN_URL" \
            '{text: $text}')

          curl --fail --silent --show-error \
            -H "Content-Type: application/json" \
            -d "$payload" \
            "$SLACK_WEBHOOK_URL"

